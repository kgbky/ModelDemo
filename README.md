# ModelDemo
图解设计模式一书 学习总结 & demo

## 面向对象6大原则
1.单一职责原则

2.开闭原则(扩展开放修改关闭)

3.里氏替换原则(在父类型的变量中保存任何一个子类的对象。程序都可以正常工作)

4.依赖倒置原则(面向接口编程，面向抽象类编程)

5.接口隔离原则(接口最小化,单一职责)

6.迪米特原则(only talk to your immediate friends)

## 心得体会
1.不要只使用具体类来编程，引用对象时优先考虑使用接口和抽象类。提高复用性和扩展性（依赖倒置原则）

2.设计模式的作用：
编写可复用（不做修改或者小幅修改即可适应新需求）、可维护、可扩展、低耦合的代码。

3.一旦在类中使用到了别的类名，就意味着该类与其他类紧密地耦合在了一起（迪米特原则）

4.抽象：不考虑具体实现，仅关注api的状态

5.继承是强耦合，委托(依赖注入实现)低耦合

6.使用了设计模式的代码，阅读起来比较绕。需要写好注释

## 设计模式
#### 1.Iterator模式
解决集合中，遍历元素的问题。

#### 2.Adapter模式
填补“现有程序”和“所需程序”间的差异。

类适配器模式（继承实现）/对象适配器模式（委托实现）

Adapter模式可以在不改变现有代码的情况下，实现新的Api，符合开闭原则

#### 3.TemplateMethod(模板方法)模式
抽取出共用逻辑或者需要遵循的规则，在模板方法中实现。

如何实现：父类（抽象类）定义模板方法，注意用final修饰

#### 4.FactoryMethod(工厂方法)模式
TemplateMethod模式用来生产实例，就变成了FactoryMethod模式

#### 5.Prototype(原型)模式
通过对象来生产实例。在Java语言中可使用Object的clone()实现
* clone()是浅拷贝，field_to_field_copy，只复制字段的引用

* clone()不会调用构造方法

* 深拷贝需要自己覆写clone()

#### 6.Builder模式
生成具有复杂结构的实例
* 设计类时，需要考虑扩展性（以应对近期可能发生的变化）、但需求总是无法预测的，不用强求。

* 阅读和修改使用了设计模式的代码时，需要充分理解整个模块的代码

#### 7.AbstractFactory(抽象工厂)模式
生成产品实例的设计模式。抽象工厂 将 抽象零件 组装成 抽象产品

该模式易于增加具体的工厂，但难以增加零件。

#### 8.Singleton(单例)模式
该类只有一个实例。主要是 懒汉式 和 饿汉式。懒汉式需要注意线程安全问题。

	* synchronized 关键字在实例方法上，锁为当前实例
	* synchronized 关键字在静态方法上，锁为当前Class对象
	* synchronized 关键字在代码块上，锁为括号里面的对象

#### 9.Bridge(桥接)模式
将类的功能层次结构 与 实现层次结构分离，在逻辑上将类一分为二，通过Bridge连接两个部分
* 类的功能层次结构：定义提供给外部调用的Api,具体的业务实现委托给 类的实现层次 部分。
  需要添加新功能时，增加子类。在子类中提供新api。

* 类的实现层次结构：真正实现具体业务逻辑的地方。继承抽象类或实现接口，并实现其中的抽象方法

* 功能层次结构和实现层次结构、分开后程序更易扩展

#### 10.Strategy(策略)模式
替换算法的模式，通过委托实现，可动态替换算法

#### 11.Composite(组合)模式
典型例子：文件系统。文件和文件夹集成同一个类。
容器与内容的一致性（一致性：把文件和文件夹都看成entry）
多个和单个的一致性(把多个对象结合在一起，当作一个对象(文件夹)处理)
* 将内容和容器作为同一种东西，形成递归结构。方便处理问题

* 递归结构和Composite模式很常见在程序世界中。 树结构的数据结构都适用Composite模式

#### 12.Decorator(装饰)模式
装饰边框与被装饰物的一致性
添加装饰边框来增加对象的功能
* 递归结构

* 添加装饰物可以添加许多新功能

#### 13.Visitor(访客)模式
封装一些施加于某种数据结构元素之上的操作，当需要修改这些操作(类)的时候，数据结构(另一些类)保持不变

* 方便扩展处理，扩展数据结构较繁琐

#### 14.Chain of Responsibility(责任链)模式
构建一条责任链，链上的类遇到自己无法处理的问题时，转交给下一个类

* 弱化了问题的提出者和解决者之间的联系。避免出现一个上帝角色知道“谁应该处理什么请求”

* 可以动态的改变责任链

* 中间环节，可能导致处理延时

#### 15.Facade（外观）模式
向系统外部提供高层接口(API)，系统内部不使用Facade角色

Facade角色封装了复杂的具体操作，系统外部只调用一个api

减少了复杂系统与调用该系统的类的耦合

#### 16.Mediator（中介者）模式
互相关联和制约的类之间，Mediator角色集中管理各个类的关系
在GUI程序中,各个控件的状态相互影响时,推荐使用该模式

* 面向对象编程可以帮助我们分散处理，中介者模式集中处理
* 依赖于特定程序和场景的代码难以复用

#### 17.Observer（观察者）模式
被观察者的状态改变时，被观察者通知观察者进行相应的处理

    提高JAVA代码的可复用性：
    
    * 利用抽象类和接口从具体类中抽出共性
    
    * 定义方法参数和类中的字段时，不使用具体类型，而使用抽象类和接口
    
    * 这种实现方式可以帮助我们轻松提高代码复用性

* 也被称为 Publish-Subscribe（发布订阅）模式

#### 18.Memento（备忘录）模式
用对象保存状态，需要时恢复。解决撤销、重做、历史记录、快照问题很有用

* wide interface(宽接口)：暴露的内容比较多,(default访问权限居多）
* narrow interface(窄接口)：该方法暴露的内容很少(可能是public的)

#### 19.State（状态）模式
用类表示状态，将复杂的程序分解
定义state接口，表示不同状态的具体类，去实现state接口

* 分而治之，将一个复杂的大问题分解为多个小问题然后逐个解决

* 容易增加新状态

#### 20.Flyweight（享元）模式
通过对象池，共享对象(都是占内存的对象)，节约内存。
同时因为减少了new关键字的使用，也提高了程序运行速度

* 修改共享对象会对所有使用的地方产生影响，仔细设计表示共享对象的类
* 不要让共享对象被JVM回收

#### 21.Proxy（代理）模式
只在必要时生成实例。生成实例要消耗较多资源(内存或时间)，延迟生成。

* 延迟操作(绝大部分是耗时或耗内存的操作)
* 代理模式有很多变种

#### 22.Command（命令）模式
GUI编程中，经常需要与"事件（按下等）"打交道，把事件用类表示，就是Command模式。

*延伸：有时，用对象表示一些抽象的“物”会带来很好的效果

#### 23.Interpreter（解释器）模式
实现自己的mini语言

其他迷你语言：正则表达式