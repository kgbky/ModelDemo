# ModelDemo
图解设计模式一书demo

## 面向对象6大原则
1.单一职责原则

2.开闭原则(不修改现有代码前提下进行扩展)

3.里氏替换原则(在父类型的变量中保存任何一个子类的对象。程序都可以正常工作)

4.依赖倒置原则(面向接口编程，面向抽象类编程)

5.接口隔离原则(接口最小化,单一职责)

6.迪米特原则(only talk to your immediate friends)

## 心得体会
1.不要只使用具体类来编程，引用对象时优先考虑使用接口和抽象类。提高复用性和扩展性

2.设计模式的作用之一：
编写可复用（不做修改或者小幅修改即可适应新需求）、可维护、可扩展、低耦合的代码。

3.一旦在类中使用到了别的类名，就意味着该类与其他类紧密地耦合在了一起

4.抽象：不考虑具体实现，仅关注api的状态

5.继承是强耦合，委托(依赖注入实现)低耦合

6.使用了设计模式的代码，阅读起来比较绕。需要写好注释

## 设计模式
#### 1.Iterator模式
解决集合中，遍历元素的问题。

#### 2.Adapter模式
填补“现有程序”和“所需程序”间的差异。

类适配器模式（继承实现）/对象适配器模式（聚合实现）

Adapter模式可以在不改变现有代码的情况下，实现新的Api，符合开闭原则

#### 3.TemplateMethod(模板方法)模式
抽取出共用逻辑或者需要遵循的规则，在模板方法中实现。

如何实现：父类（抽象类）定义模板方法，注意用final修饰

#### 4.FactoryMethod(工厂方法)模式
TemplateMethod模式用来生产实例，就变成了FactoryMethod模式

#### 5.Prototype(原型)模式
通过对象来生产实例。在Java语言中可使用Object的clone()实现
* clone()是浅拷贝，field_to_field_copy，只复制字段的引用

* clone()不会调用构造方法

* 深拷贝需要自己覆写clone()

#### 6.Builder模式
组装具有复杂结构的实例
* 设计类时，需要考虑扩展性（以应对近期可能发生的变化）、但需求总是无法预测的，不用强求。

* 阅读和修改使用了设计模式的代码时，需要充分理解整个模块的代码

#### 7.AbstractFactory(抽象工厂)模式
生成产品实例的设计模式。抽象工厂 将 抽象零件 组装成 抽象产品

该模式易于增加具体的工厂，但难以增加零件。

#### 8.Singleton(单例)模式
该类只有一个实例

#### 9.Bridge(桥接)模式
将类的功能层次结构 与 实现层次结构分离，在逻辑上将类一分为二，通过Bridge连接两个部分
* 类的功能层次结构：定义提供给外部调用的Api,具体的业务实现委托给 类的实现层次 部分。
子类继承父类，添加新方法(可添加新功能)。

* 类的实现层次结构：真正实现具体业务逻辑的地方。继承抽象类或实现接口，并实现其中的抽象方法

* 功能层次结构和实现层次结构、分开后程序更易扩展

#### 10.Strategy(策略)模式
替换算法的模式。

通过委托实现动态替换算法

#### 11.Composite(组合)模式
容器与内容的一致性（一致性：把不同的东西看做同一种东西）
多个和单个的一致性(把多个对象结合在一起，当作一个对象处理)
* 将内容和容器作为同一种东西，形成递归结构。方便处理问题

* 递归结构和Composite模式很常见

* 树结构的数据结构都适用Composite模式

#### 12.Decorator(装饰)模式
装饰边框与被装饰物的一致性
添加装饰边框来增加对象的功能
* 递归结构

* 添加装饰物可以添加许多新功能

#### 13.Visitor模式
访问数据结构并处理数据，数据结构与处理被分离开来

* 方便扩展处理，扩展数据结构较难

#### 14.Chain of Responsibility（责任链）模式
自己能处理就处理，不能处理就转给下一个人

* 避免出现一个上帝角色知道“谁应该处理什么请求”

* 可以动态的改变责任链

* 会导致处理延迟   

#### 15.Facade（外观）模式
向系统外部提供高层接口(API)，系统内部不使用Facade角色

Facade角色封装了复杂的具体操作，系统外部只调用一个api

减少了复杂系统与调用该系统的类的耦合

#### 16.Mediator（中介者）模式
互相关联和制约的类之间，Mediator角色集中管理各个类的关系
在GUI程序中,推荐使用该模式

* 面向对象编程可以帮助我们分散处理，中介者模式集中处理
* 依赖于特定程序和场景的代码难以复用

#### 17.Observer（观察者）模式
被观察的对象状态改变时，观察者进行相应的处理

    JAVA的可替代性：
    
    * 抽象类和接口从具体类中抽出共性
    
    * 传递参数、类的字段的属性，不使用具体类型，而使用抽象类和接口
    
    * 这样的实现方式可以帮助我们轻松替换具体类

* 也被称为 Publish-Subscribe（发布订阅）模式

#### 18.Memento（备忘录）模式
保存对象的状态，必要时恢复。
用对象保存状态

* wide interface(宽接口)：暴露的内容比较多,(default访问权限居多）
* narrow interface(窄接口)：改方法操作的内容很少(可能是public的)

#### 19.State（状态）模式
用类表示状态，将复杂的程序分解
定义state接口，表示不同状态的具体类，去实现state接口

* 分而治之，将一个复杂的大问题分解为多个小问题然后逐个解决

* 容易增加新状态

#### 20.Flyweight（享元）模式
共享对象，避免浪费(内存)。减少了new关键字的使用，提高运行速度

    JAVA：
    
    
    * JVM在内存不足时，开始垃圾回收。被引用的对象不会被回收
    
    * 内存、时间、在计算机里都是一种资源
    
* 修改一个元数据对所有地方产生影响，仔细考虑哪些是元数据

#### 21.Proxy（代理）模式
只在必要时生成实例，生成实例比较费时费力
"本人"太忙，将一部分工作交给"代理人"

* 延迟处理耗时或耗内存的操作

#### 22.Command（命令）模式
GUI编程中，经常需要与"事件（Command类）"打交道

#### 23.Interpreter（解释器）模式
实现mini语言